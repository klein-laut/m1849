<!-- /templates/product.liquid -->

<div itemscope itemtype="http://schema.org/Product">

  <meta itemprop="url" content="{{ shop.url }}{{ product.url }}">
  <meta itemprop="image" content="{{ product.featured_image.src | img_url: 'grande' }}">

  {% assign current_variant = product.selected_or_first_available_variant %}

  <div class="grid product-single">
    <div class="grid__item large--eight-twelfths medium--one-whole text-center">
      {% include 'product-images' %}
    </div>
    <div class="grid__item product-single__meta--wrapper medium--one-whole large--four-twelfths">
      <div class="product-single__meta">
        {% if settings.product_vendor_enable %}
          <h2 class="product-single__vendor" itemprop="brand">{{ product.vendor }}</h2>
        {% endif %}

        <h1 class="product-single__title color-code" itemprop="name">{{ product.title }}</h1>
        <div itemprop="offers" itemscope itemtype="http://schema.org/Offer">
          {% comment %}
            Optionally show the 'compare at' or original price of the product.
          {% endcomment %}

          {% comment %}
            {% if product.compare_at_price > product.price %}
              <span class="product-single__price--wrapper">
                <span class="visually-hidden">{{ 'products.general.regular_price' | t }}</span>
                <span id="ComparePrice" class="product-single__price--compare-at">
                  {{ product.compare_at_price | money }}
                </span>
                <span class="visually-hidden">{{ 'products.general.sale_price' | t }}</span>
              </span>
            {% endif %}
          {% endcomment %}
        </div>

        <div class="product-single__description rte" itemprop="description">
          {% comment%}
          
            -- Getting Collections --
            In order to get the bottom level collection, we're finding the collection
            that only has one product type and that product is exactly the product
            type of our current product.
            
            The top level collection is found based on if every product from the bottom
            level collection is found within the top level. This ensures that other
            collections such as 'all' or 'newest' won't corrupt the fetching of these collections.
          
          {% endcomment%}
          {% for collection in product.collections %}
            {% if collection.all_types.size == 1 && collection.all_types contains product.type %}
              {% assign bottom_level_collection = collection %}
            {% endif %}
          {% endfor %}
          
          {% for collection in product.collections %}
            {% unless collection.id == bottom_level_collection.id %}
              {% assign match = true %}
              {% for _product in bottom_level_collection.products %}
                {% assign collection_ids = _product.collections | map: "id" %}
                {% unless collection_ids contains collection.id %}
                  {% assign match = false %}
                {% endunless %}
              {% endfor %}
            
              {% if match %}
                {% assign top_level_collection = collection%}
              {% endif %}
            {% endunless %}
          {% endfor %}
          
          <div class="collections">
            <h3><a href="{{ bottom_level_collection.url }}">{{ bottom_level_collection.title }}</a></h3>
            <h4><a href="{{ top_level_collection.url }}">{{ top_level_collection.title }}</a></h4>
          </div>
          {% if product.tags contains 'M49' or product.tags contains 'm49' %}
            <a href="/collections/all/M49" class="btn">M49</a>
          {% endif %}
          {{ product.description }}
        </div>
        <div class="specs tabular">
          {% assign made_in_places = "italy,asia" | split: "," %}
          <div class="tabs">
            {% assign first_tab = true %}
            {% for place in made_in_places %}
              {% assign place_fields = product.metafields[place] | size %}
              {% if place_fields > 0 %}
                <a href="#{{place}}" class="{% if first_tab %}active{% endif %}" data-tab="{{ place }}">{{ place | capitalize }}</a>
                {% assign first_tab = false %}
              {% endif %}
            {% endfor %}
          </div>
          <div class="tab-content">
            {% assign first_tab = true %}
            {% for place in made_in_places %}
              {% assign place_fields = product.metafields[place] | size %}
              {% if place_fields > 0 %}
                <div class="tab {% if first_tab %}active{% endif %}" data-tab="{{ place }}">
                  <table>
                    <tbody>
                      {% for field in product.metafields[place] %}
                        <tr>
                          {% assign key = field[0] | split: "_" %}
                          <td>{% for word in key %}{{word | capitalize}} {% endfor %}</td>
                          <td {% if field[0] == "color_code" %}data-color-code="{{ field[1] }}"{% endif %}>
                            {% assign link_keys = "temple,side" | split: ","  %}
                            {% if link_keys contains field[0] %}
                              <a href="/products/{{ field[1] }}">{{ field[1] }}</a>
                            {% else %}
                              {{ field[1] }}
                            {% endif %}
                          </td>
                        </tr>
                      {% endfor %}
                    </tbody>
                  </table>
                </div>
                {% assign first_tab = false %}
              {% endif %}
            {% endfor %}
          </div>
        </div>

        {% include 'product-form' %}
        {% if settings.social_sharing_products %}
          {% include 'social-sharing' %}
        {% endif %}
      </div>
    </div>
  </div>
  <div class="product-extras related-lookbooks">
    <div class="attachments">
      <a href="{{ settings.global_spec_url }}" class="btn">Specifications</a>
      {% for attachment in product.metafields.attachments %}
        {% unless attachment == blank %}
          <a href="{{ attachment[1] }}" class="btn">{{ attachment[0] | capitalize }}</a>
        {% endunless %}
      {% endfor %}
    </div>
    <h3>Featured In</h3>
    <div class="lookbooks-container" data-relatable="product.article" data-relatable-id="{{product.id}}">
      {% raw %}
        {{#article}}
          <a href="/blogs/lookbook/{{article.id}}" class="product-lookbook">
            <img src="{{article.image.src}}" alt="">
            <h3>{{article.title}}</h3>
            <p>{{{article.summary_html}}}</p>
          </a>
        {{/article}}
      {% endraw %}
    </div>
  </div>
  <div class="product-extras related-products">
    <h3>
      Products in Category
      <a href="{{ product.collections.first.url }}" class="more-styles">{{ product.collections.first.products.size }} more styles</a>
    </h3>
    <div class="slick-items">
      {% for _product in product.collections.first.products %}
        <div class="related-product product-card">
          <a href="{{ _product.url }}">
            {% if _product.featured_image %}
              {% assign img_url = _product.featured_image | img_url: "compact" %}
            {% else %}
              {% assign img_url = 'no-image-compact.png' | asset_url %}
            {% endif %}
            <img src="{{ img_url }}" alt="{{ product.title | escape }}" />
          </a>
        </div>
      {% endfor %}
    </div>
  </div>
  {% if collection %}
    <hr class="hr--clear">
    <div class="text-center">
      <a href="{{ collection.url }}" class="return-link">&larr; {{ 'products.general.collection_return' | t: collection: collection.title }}</a>
    </div>
  {% endif %}

</div>

{% comment %}

  *IMPORTANT:*
  This theme uses a customized version of `option_selection.js` to support using radio inputs for
  color and size variants. The custom version is in `variant_selection.js`.

  If you wish to enable the default dropdowns for size and color
  you can change the liquid asset tag below from:

  {{ 'variant_selection.js' | asset_url | script_tag }}

  to

  {{ 'option_selection.js' | shopify_asset_url | script_tag }}

  If you use the default `option_selection.js` the labels for the dropdowns will
  appear outside the dropdown.

  You will also need to change `.radio-wrapper` to `.selector-wrapper` below.

  {{ 'variant_selection.js' | asset_url | script_tag }}
{% endcomment %}

<script>
  // var selectCallback = function(variant, selector) {
  //   timber.productPage({
  //     money_format: "{{ shop.money_format }}",
  //     variant: variant,
  //     selector: selector,
  //     translations: {
  //       addToCart : {{ 'products.product.add_to_cart' | t | json }},
  //       soldOut : {{ 'products.product.sold_out' | t | json }},
  //       unavailable : {{ 'products.product.unavailable' | t | json }}
  //     }
  //   });
  // };
  //
  // jQuery(function($) {
  //   new Shopify.OptionSelectors('ProductSelect', {
  //     product: {{ product | json }},
  //     onVariantSelected: selectCallback,
  //     enableHistoryState: true
  //   });
  //
  //   // Add label if only one product option and it isn't 'Title'. Could be 'Size'.
  //   {% if product.options.size == 1 and product.options.first != 'Title' %}
  //     $('.radio-wrapper:eq(0)').prepend('<label for="ProductSelect-option-0" class="single-option-radio__label">{{ product.options.first | escape }}</label>');
  //   {% endif %}
  //
  //   // Hide drop-down selectors if we only have 1 variant and its title contains 'Default'.
  //   {% if product.variants.size == 1 and product.variants.first.title contains 'Default' %}
  //     $('.selector-wrapper').hide();
  //   {% endif %}
  // });
</script>
